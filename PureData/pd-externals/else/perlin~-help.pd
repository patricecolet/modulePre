#N canvas 443 23 561 487 10;
#X obj 215 162 hsl 128 15 100 10000 1 0 empty empty empty -2 -8 0 10
#dcdcdc #000000 #000000 0 1;
#X obj 306 4 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc
0;
#N canvas 382 141 749 319 (subpatch) 0;
#X coords 0 -1 1 1 252 42 2 100 100;
#X restore 305 3 pd;
#X obj 345 11 cnv 10 10 10 empty empty ELSE 0 15 2 30 #7c7c7c #e0e4dc
0;
#X obj 23 40 cnv 4 4 4 empty empty Perlin 0 28 2 18 #e0e0e0 #000000
0;
#X obj 458 11 cnv 10 10 10 empty empty EL 0 6 2 13 #7c7c7c #e0e4dc
0;
#X obj 478 11 cnv 10 10 10 empty empty Locus 0 6 2 13 #7c7c7c #e0e4dc
0;
#X obj 464 26 cnv 10 10 10 empty empty ELSE 0 6 2 13 #7c7c7c #e0e4dc
0;
#X obj 75 40 cnv 4 4 4 empty empty noise 0 28 2 18 #e0e0e0 #000000
0;
#X obj 3 456 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020
0;
#X obj 3 301 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000
0;
#X obj 3 352 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000
0;
#X obj 3 427 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000
0;
#X obj 94 361 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0
;
#X obj 92 310 cnv 17 3 34 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0
;
#X text 160 362 signal;
#X text 147 434 1) float;
#X obj 212 186 nbx 5 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
#dcdcdc #000000 #000000 0 256;
#X text 124 311 float/signal;
#X obj 123 40 cnv 4 4 4 empty empty generator 0 28 2 18 #e0e0e0 #000000
0;
#X obj 212 236 else/out~;
#X text 207 434 - sets frequency in hertz (default: nyquist);
#X obj 2 3 cnv 15 301 42 empty empty perlin~ 20 20 2 37 #e0e0e0 #000000
0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 302 42 1 0 0;
#X restore 2 3 graph;
#X text 271 186 frequency in Hz;
#X text 207 363 - perlin noise signal;
#X text 207 311 - frequency in hertz;
#X obj 212 211 else/perlin~;
#X text 129 327 seed <float> - a float sets seed \, no float sets a
unique internal, f 65;
#N canvas 301 91 871 308 seed 0;
#X text 31 58 Pseudo random number generators like [white~] aren't
true random number generators. Instead \, an algorithm is used to provide
a sequence of numbers that seems random. The same sequence can be reproduced
if you set a "seed" value \, which can be any integer number., f 52
;
#X text 31 130 You can set a seed to [perlin~]'s [white~] noise. Seeds
are kept locally \, which means that if two objects are seeded the
same they will have the same output. Conversely \, you can seed the
same object twice with the same seed to repeat the output., f 52;
#X text 31 201 You can also set a seed with the argument. If you don't
supply it \, each object gets its own internal seed. If you send a
'seed' message without float \, the object also gets a unique seed
value., f 52;
#X text 400 36 Sync [perlin~] objects with a seed value;
#X msg 608 73 seed;
#X msg 384 73 seed 973;
#X obj 608 172 else/oscope~ 200 100 256 3 128 -1 1 0 0 0 0 30 30 30
190 190 190 160 160 160 0 empty;
#X obj 384 173 else/oscope~ 200 100 256 3 128 -1 1 0 0 0 0 30 30 30
190 190 190 160 160 160 0 empty;
#X obj 384 127 else/perlin~ -seed 973 3;
#X obj 608 130 else/perlin~ -seed 973 3;
#X connect 4 0 8 0;
#X connect 4 0 9 0;
#X connect 5 0 8 0;
#X connect 5 0 9 0;
#X connect 8 0 7 0;
#X connect 9 0 6 0;
#X restore 472 262 pd seed;
#X text 74 86 [perlin~] is an abastraction that implements 1-dimensional
Perlin Noise (a type of gradient noise developed by Ken Perlin). It
uses [white~] as a noise source into a sample and hold function and
generates smoothened functions according to a frequency value in hertz
(values under 0 and above nyquist are aliased)., f 71;
#X obj 7 389 cnv 3 550 3 empty empty flags 8 12 0 13 #dcdcdc #000000
0;
#X text 144 400 -seed <float>: sets seed (default: unique internal)
;
#X connect 0 0 17 0;
#X connect 17 0 27 0;
#X connect 27 0 20 0;
